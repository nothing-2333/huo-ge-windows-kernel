# 内容概述
封装的驱动通信代码、总结

# r3
```c
#include "stdafx.h"
#include <Windows.h>

#define _SYM_NAME L"\\\\.\\test"

#define CODE_CTR_INDEX 0x800
#define TEST CTL_CODE(FILE_DEVICE_UNKNOWN, CODE_CTR_INDEX, METHOD_BUFFERED, FILE_ANY_ACCESS)

int main()
{
	HANDLE hDevice = CreateFile(_SYM_NAME, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (!hDevice)
	{
		printf("打开设备失败 %d\r\n", GetLastError());

	}
	else
	{
		system("pause");

		ULONG input = 10;
		ULONG64 output = 0;
		ULONG reLength = 0;
		BOOL isSuccess = DeviceIoControl(hDevice, TEST, &input, 4, &output, 8, &reLength, 0);
		printf("sucess %d, %d\r\n", isSuccess, GetLastError());
		printf("output %d, %x\r\n", output);

		system("pause");

	}

	system("pause");
	return 0;
}
```

# r0
```c
#include <ntifs.h>

#define _DEVIDE_NAME L"\\device\\test"
#define _SYM_NAME L"\\??\\test"

#define CODE_CTR_INDEX 0x800
#define TEST CTL_CODE(FILE_DEVICE_UNKNOWN, CODE_CTR_INDEX, METHOD_BUFFERED, FILE_ANY_ACCESS)


VOID DriverUnload(PDRIVER_OBJECT pDriver)
{
	if (pDriver->DeviceObject)
	{
		UNICODE_STRING un_sym_name = { 0 };
		RtlInitUnicodeString(&un_sym_name, _SYM_NAME);
		IoDeleteSymbolicLink(&un_sym_name);

		UNICODE_STRING un_device_name = { 0 };
		RtlInitUnicodeString(&un_device_name, _DEVIDE_NAME);
		IoDeleteSymbolicLink(&un_device_name);
	}
	DbgPrint("-----------DriverUnload---------------\r\n");
}

NTSTATUS deflaultDispatch(DEVICE_OBJECT *DeviceObject, IRP *Irp)
{
	Irp->IoStatus.Status = STATUS_SUCCESS;
	DbgPrintEx(77, 0, "[db]: deflaultDispatch\r\n");
	IoCompleteRequest(Irp, 0);
	return STATUS_SUCCESS;
}

NTSTATUS dispatch(DEVICE_OBJECT *DeviceObject, IRP *Irp)
{
	PIO_STACK_LOCATION io = IoGetCurrentIrpStackLocation(Irp);
	DbgPrintEx(77, 0, "[db]: MajorFunction %x\r\n", io->MajorFunction);
	DbgPrintEx(77, 0, "[db]: InputBufferLength %x\r\n", io->Parameters.DeviceIoControl.InputBufferLength);
	DbgPrintEx(77, 0, "[db]: OutputBufferLength %x\r\n", io->Parameters.DeviceIoControl.OutputBufferLength);
	DbgPrintEx(77, 0, "[db]: IoControlCode %x\r\n", io->Parameters.DeviceIoControl.IoControlCode);
	DbgPrintEx(77, 0, "[db]: SystemBuffer %x, %x\r\n", Irp->AssociatedIrp.SystemBuffer, *(ULONG*)Irp->AssociatedIrp.SystemBuffer);

	// 更改返回值
	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = io->Parameters.DeviceIoControl.OutputBufferLength;
	*(ULONG*)Irp->AssociatedIrp.SystemBuffer = 0x200;

	IoCompleteRequest(Irp, 0);
	return STATUS_SUCCESS;
}

NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg)
{
	UNICODE_STRING un_device_name = { 0 };
	RtlInitUnicodeString(&un_device_name, _DEVIDE_NAME);

	// 创建设备对象
	PDEVICE_OBJECT pDevice = NULL;
	NTSTATUS status = IoCreateDevice(pDriver, 0, &un_device_name, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &pDevice);
	if (!NT_SUCCESS(status))
	{
		return STATUS_UNSUCCESSFUL;
	}

	UNICODE_STRING un_sym_name = { 0 };
	RtlInitUnicodeString(&un_sym_name, _SYM_NAME);

	// 创建设备对象的符号链接
	status = IoCreateSymbolicLink(&un_sym_name, &un_device_name);
	if (!NT_SUCCESS(status))
	{
		IoDeleteDevice(pDevice);
		return STATUS_UNSUCCESSFUL;
	}

	// 改变设备属性
	pDevice->Flags &= DO_DEVICE_INITIALIZING;	// 去掉未初始化标志
	pDevice->Flags |= DO_BUFFERED_IO;			// 选取使用内存类型

												// 设置回调函数
	pDriver->MajorFunction[IRP_MJ_CREATE] = deflaultDispatch;
	pDriver->MajorFunction[IRP_MJ_CLOSE] = deflaultDispatch;
	pDriver->MajorFunction[IRP_MJ_DEVICE_CONTROL] = dispatch;

	pDriver->DriverUnload = DriverUnload;
	return STATUS_SUCCESS;
}
```